import path from "node:path";
import { pathToFileURL } from "node:url";

import fg from "fast-glob";

import { writeFile } from "./utils/fs";

export interface EmitConnectQueryOptions {
	connectDir: string;
}

function trimExtension(filePath: string): string {
	return filePath.replace(/\.[cm]?[jt]sx?$/u, "");
}

/**
 * Generates companion `*_connectquery.ts` files alongside `*_connect.ts` files.
 * These re-export individual method descriptors from the service, allowing consumers
 * to import them directly (matching the original Buf style):
 *
 * ```ts
 * // Instead of:
 * import { DesktopService } from './desktop_connect.js'
 * const method = DesktopService.methods.completeLogin
 *
 * // Consumers can do:
 * import { completeLogin } from './desktop_connectquery.js'
 * ```
 */
export async function emitConnectQuery(
	options: EmitConnectQueryOptions,
): Promise<void> {
	const { connectDir } = options;

	const normalizedConnect = connectDir.replace(/[\\/]+$/, "");
	const pattern = `${normalizedConnect}/**/*_connect.{js,cjs,mjs,ts,tsx}`;
	const connectFiles = await fg(pattern, { absolute: true });

	for (const file of connectFiles) {
		const moduleUrl = pathToFileURL(file).href;
		const moduleExports: Record<string, unknown> = await import(moduleUrl);

		// Collect all services and their methods from this file
		const serviceExports: Array<{
			serviceName: string;
			methodNames: string[];
		}> = [];

		for (const key of Object.keys(moduleExports)) {
			// biome-ignore lint/suspicious/noExplicitAny: Dynamic introspection of Connect service definitions
			const svc = moduleExports[key] as any;
			if (
				svc &&
				typeof svc === "object" &&
				"typeName" in svc &&
				"methods" in svc
			) {
				const serviceName = key;
				// biome-ignore lint/suspicious/noExplicitAny: Dynamic introspection of Connect service method definitions
				const methods = Object.values(svc.methods) as any[];
				const methodNames = methods.map((m) => m.name);

				if (methodNames.length > 0) {
					serviceExports.push({ serviceName, methodNames });
				}
			}
		}

		// Skip if no services found in this file
		if (serviceExports.length === 0) {
			continue;
		}

		// Generate the connectquery file alongside the connect file
		const connectQueryFile = file.replace(
			/_connect\.(js|ts|mjs|cjs|tsx)$/u,
			"_connectquery.ts",
		);
		// Get basename without extension (e.g., "service_connect" from "service_connect.ts")
		const connectBasename = path.basename(trimExtension(file));

		// Build the code
		const imports = serviceExports.map((s) => s.serviceName).join(", ");

		const exports = serviceExports
			.map(({ serviceName, methodNames }) => {
				// Use destructuring for concise re-exports
				const names = methodNames.join(", ");
				return `export const { ${names} } = ${serviceName}.methods;`;
			})
			.join("\n\n");

		const code = `// Auto-generated by proto-to-trpc
// Re-exports method descriptors for direct imports (Buf-style ergonomics)

import { ${imports} } from "./${connectBasename}.js";

${exports}
`;

		await writeFile(connectQueryFile, code);
	}
}
